async_container.py
from __future__ import annotations
import warnings
from asyncio import Lock
from collections.abc import Callable, MutableMapping
from contextlib import AbstractAsyncContextManager
from types import TracebackType
from typing import Any, TypeVar, cast, overload
from dishka.entities.component import DEFAULT_COMPONENT, Component
from dishka.entities.factory_type import FactoryType
from dishka.entities.key import DependencyKey
from dishka.entities.marker import Has, HasContext
from dishka.entities.scope import BaseScope, Scope
from dishka.provider import Provider, activate
from .container_objects import Exit
from .context_proxy import ContextProxy
from .dependency_source import Factory
from .entities.validation_settings import (
    DEFAULT_VALIDATION,
    ValidationSettings,
)
from .exceptions import (
    ChildScopeNotFoundError,
    ExitError,
    NoActiveFactoryError,
    NoChildScopesError,
    NoFactoryError,
    NoNonSkippedScopesError,
)
from .graph_builder.builder import GraphBuilder
from .provider import BaseProvider, make_root_context_provider
from .registry import Registry
T = TypeVar("T")
class AsyncContainer:
    __slots__ = (
        "_cache",
        "_context",
        "_exits",
        "child_registries",
        "close_parent",
        "lock",
        "parent_container",
        "registry",
    )
    def __init__(
            self,
            registry: Registry,
            *child_registries: Registry,
            parent_container: AsyncContainer | None = None,
            context: dict[Any, Any] | None = None,
            lock_factory: Callable[
                [], AbstractAsyncContextManager[Any],
            ] | None = None,
            close_parent: bool = False,
    ):
        self.registry = registry
        self.child_registries = child_registries
        self._context = {CONTAINER_KEY: self}
        if context:
            self._context.update(context)
        self._cache = {CONTAINER_KEY: self}
        self.parent_container = parent_container
        self.lock: AbstractAsyncContextManager[Any] | None
        if lock_factory:
            self.lock = lock_factory()
        else:
            self.lock = None
        self._exits: list[Exit] = []
        self.close_parent = close_parent
    @property
    def scope(self) -> BaseScope:
        return self.registry.scope
    @property
    def context(self) -> MutableMapping[DependencyKey, Any]:
        warnings.warn(
            "`container.context` is deprecated",
            DeprecationWarning,
            stacklevel=2,
        )
        return ContextProxy(cache=self._cache, context=self._context)
    def __call__(
            self,
            context: dict[Any, Any] | None = None,
            lock_factory: Callable[
                [], AbstractAsyncContextManager[Any],
            ] | None = None,
            scope: BaseScope | None = None,
    ) -> AsyncContextWrapper:
        """
        Prepare container for entering the inner scope.
        :param context: Data which will available in inner scope
        :param lock_factory: Callable to create lock instance or None
        :param scope: target scope or None to enter next non-skipped scope
        :return: async context manager for inner scope
        """
        if not self.child_registries:
            raise NoChildScopesError
        child = AsyncContainer(
            *self.child_registries,
            parent_container=self,
            context=context,
            lock_factory=lock_factory,
        )
        if scope is None:
            while child.registry.scope.skip:
                if not child.child_registries:
                    raise NoNonSkippedScopesError
                child = AsyncContainer(
                    *child.child_registries,
                    parent_container=child,
                    context=context,
                    lock_factory=lock_factory,
                    close_parent=True,
                )
        else:
            while child.registry.scope is not scope:
                if not child.child_registries:
                    raise ChildScopeNotFoundError(scope, self.registry.scope)
                child = AsyncContainer(
                    *child.child_registries,
                    parent_container=child,
                    context=context,
                    lock_factory=lock_factory,
                    close_parent=True,
                )
        return AsyncContextWrapper(child)
    @overload
    async def get(
            self,
            dependency_type: type[T],
            component: Component | None = DEFAULT_COMPONENT,
    ) -> T:
        ...
    @overload
    async def get(
            self,
            dependency_type: Any,
            component: Component | None = DEFAULT_COMPONENT,
    ) -> Any:
        ...
    async def get(
            self,
            dependency_type: Any,
            component: Component | None = DEFAULT_COMPONENT,
    ) -> Any:
        lock = self.lock
        key = DependencyKey(dependency_type, component)
        try:
            if not lock:
                return await self._get_unlocked(key)
            async with lock:
                return await self._get_unlocked(key)
        except (NoFactoryError, NoActiveFactoryError) as e:
            e.scope = self.scope
            raise
    async def _get(self, key: DependencyKey) -> Any:
        lock = self.lock
        if not lock:
            return await self._get_unlocked(key)
        async with lock:
            return await self._get_unlocked(key)
    async def _get_unlocked(self, key: DependencyKey) -> Any:
        if key in self._cache:
            return self._cache[key]
        compiled = self.registry.get_compiled_async(key)
        if not compiled:
            if not self.parent_container:
                abstract_dependencies = (
                    self.registry.get_more_abstract_factories(key)
                )
                concrete_dependencies = (
                    self.registry.get_more_concrete_factories(key)
                )
                raise NoFactoryError(
                    key,
                    suggest_abstract_factories=abstract_dependencies,
                    suggest_concrete_factories=concrete_dependencies,
                )
            try:
                return await self.parent_container._get(key)  # noqa: SLF001
            except NoFactoryError as ex:
                abstract_dependencies = (
                    self.registry.get_more_abstract_factories(key)
                )
                concrete_dependencies = (
                    self.registry.get_more_concrete_factories(key)
                )
                ex.suggest_abstract_factories.extend(abstract_dependencies)
                ex.suggest_concrete_factories.extend(concrete_dependencies)
                raise
        try:
            return await compiled(
                self._get_unlocked,
                self._exits,
                self._cache,
                self._context,
            )
        except NoFactoryError as e:
            # cast is needed because registry.get_factory will always
            # return Factory. This happens because registry.get_compiled
            # uses the same method and returns None if the factory is not found
            # If None is returned, then go to the parent container
            e.add_path(cast(Factory, self.registry.get_factory(key)))
            raise
        except NoActiveFactoryError as e:
            e.add_path(cast(Factory, self.registry.get_factory(key)))
            raise
    async def close(self, exception: BaseException | None = None) -> None:
        errors = []
        for exit_generator in self._exits[::-1]:
            try:
                if exit_generator.type is FactoryType.ASYNC_GENERATOR:
                    await exit_generator.callable.asend(exception)  # type: ignore[attr-defined]
                elif exit_generator.type is FactoryType.GENERATOR:
                    exit_generator.callable.send(exception)  # type: ignore[attr-defined]
            except StopIteration:  # noqa: PERF203
                pass
            except StopAsyncIteration:
                pass
            except Exception as err:  # noqa: BLE001
                errors.append(err)
        self._cache = {CONTAINER_KEY: self}
        if self.close_parent and self.parent_container:
            try:
                await self.parent_container.close(exception)
            except Exception as err:  # noqa: BLE001
                errors.append(err)
        if errors:
            raise ExitError("Cleanup context errors", errors)  # noqa: TRY003
    async def _has(self, marker: Any) -> bool:
        compiled = self.registry.get_compiled_activation_async(marker)
        if not compiled:
            if not self.parent_container:
                return False
            return await self.parent_container._has(marker)  # noqa: SLF001

        return bool(await compiled(
            self._get_unlocked,
            self._exits,
            self._cache,
            self._context,
        ))
    def _has_context(self, marker: Any) -> bool:
        return marker in self._context
class AsyncContextWrapper:
    def __init__(self, container: AsyncContainer):
        self.container = container
    async def __aenter__(self) -> AsyncContainer:
        return self.container
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None = None,
        exc_val: BaseException | None = None,
        exc_tb: TracebackType | None = None,
    ) -> None:
        await self.container.close(exception=exc_val)
class HasProvider(Provider):
    @activate(Has)
    async def has(
        self,
        marker: DependencyKey,
        container: AsyncContainer,
    ) -> bool:
        key = DependencyKey(marker.type_hint.value, marker.component)
        return await container._has(key)  # noqa: SLF001
    @activate(HasContext)
    def has_context(
        self,
        marker: HasContext,
        container: AsyncContainer,
    ) -> bool:
        return container._has_context(marker.value)  # noqa: SLF001
def make_async_container(
        *providers: BaseProvider,
        scopes: type[BaseScope] = Scope,
        context: dict[Any, Any] | None = None,
        lock_factory: Callable[
            [], AbstractAsyncContextManager[Any],
        ] | None = Lock,
        skip_validation: bool = False,
        start_scope: BaseScope | None = None,
        validation_settings: ValidationSettings = DEFAULT_VALIDATION,
) -> AsyncContainer:
    context_provider = make_root_context_provider(providers, context, scopes)
    has_provider = HasProvider()
    builder = GraphBuilder(
        scopes=scopes,
        container_key=CONTAINER_KEY,
        skip_validation=skip_validation,
        validation_settings=validation_settings,
    )
    builder.add_multicomponent_providers(has_provider)
    builder.add_providers(*providers)
    builder.add_providers(context_provider)
    registries = builder.build()
    container = AsyncContainer(
        *registries,
        context=context,
        lock_factory=lock_factory,
    )
    if start_scope is None:
        while container.registry.scope.skip:
            container = AsyncContainer(
                *container.child_registries,
                parent_container=container,
                context=context,
                lock_factory=lock_factory,
                close_parent=True,
            )
    else:
        while container.registry.scope is not start_scope:
            container = AsyncContainer(
                *container.child_registries,
                parent_container=container,
                context=context,
                lock_factory=lock_factory,
                close_parent=True,
            )
    return container
CONTAINER_KEY = DependencyKey(AsyncContainer, DEFAULT_COMPONENT)
from __future__ import annotations

import warnings
from collections.abc import Callable, MutableMapping
from contextlib import AbstractContextManager
from threading import Lock
from types import TracebackType
from typing import Any, TypeVar, cast, overload

from dishka.entities.component import DEFAULT_COMPONENT, Component
from dishka.entities.factory_type import FactoryType
from dishka.entities.key import DependencyKey
from dishka.entities.marker import Has, HasContext
from dishka.entities.scope import BaseScope, Scope
from dishka.provider import Provider, activate
from .container_objects import Exit
from .context_proxy import ContextProxy
from .dependency_source import Factory
from .entities.validation_settings import (
    DEFAULT_VALIDATION,
    ValidationSettings,
)
from .exceptions import (
    ChildScopeNotFoundError,
    ExitError,
    NoActiveFactoryError,
    NoChildScopesError,
    NoFactoryError,
    NoNonSkippedScopesError,
)
from .graph_builder.builder import GraphBuilder
from .provider import BaseProvider, make_root_context_provider
from .registry import Registry
T = TypeVar("T")
class Container:
    __slots__ = (
        "_cache",
        "_context",
        "_exits",
        "child_registries",
        "close_parent",
        "lock",
        "parent_container",
        "registry",
    )
    def __init__(
            self,
            registry: Registry,
            *child_registries: Registry,
            parent_container: Container | None = None,
            context: dict[Any, Any] | None = None,
            lock_factory: Callable[
                [], AbstractContextManager[Any],
            ] | None = None,
            close_parent: bool = False,
    ):
        self.registry = registry
        self.child_registries = child_registries
        self._context = {CONTAINER_KEY: self}
        if context:
            self._context.update(context)
        self._cache = {CONTAINER_KEY: self}
        self.parent_container = parent_container

        self.lock: AbstractContextManager[Any] | None
        if lock_factory:
            self.lock = lock_factory()
        else:
            self.lock = None
        self._exits: list[Exit] = []
        self.close_parent = close_parent

    @property
    def scope(self) -> BaseScope:
        return self.registry.scope

    @property
    def context(self) -> MutableMapping[DependencyKey, Any]:
        warnings.warn(
            "`container.context` is deprecated",
            DeprecationWarning,
            stacklevel=2,
        )
        return ContextProxy(cache=self._cache, context=self._context)

    def __call__(
            self,
            context: dict[Any, Any] | None = None,
            lock_factory: Callable[
                [], AbstractContextManager[Any],
            ] | None = None,
            scope: BaseScope | None = None,
    ) -> ContextWrapper:
        if not self.child_registries:
            raise NoChildScopesError
        child = Container(
            *self.child_registries,
            parent_container=self,
            context=context,
            lock_factory=lock_factory,
        )
        if scope is None:
            while child.registry.scope.skip:
                if not child.child_registries:
                    raise NoNonSkippedScopesError
                child = Container(
                    *child.child_registries,
                    parent_container=child,
                    context=context,
                    lock_factory=lock_factory,
                    close_parent=True,
                )
        else:
            while child.registry.scope is not scope:
                if not child.child_registries:
                    raise ChildScopeNotFoundError(scope, self.registry.scope)
                child = Container(
                    *child.child_registries,
                    parent_container=child,
                    context=context,
                    lock_factory=lock_factory,
                    close_parent=True,
                )
        return ContextWrapper(child)
    @overload
    def get(
            self,
            dependency_type: type[T],
            component: Component | None = DEFAULT_COMPONENT,
    ) -> T:
        ...
    @overload
    def get(
            self,
            dependency_type: Any,
            component: Component | None = DEFAULT_COMPONENT,
    ) -> Any:
        ...
    def get(
            self,
            dependency_type: Any,
            component: Component | None = DEFAULT_COMPONENT,
    ) -> Any:
        lock = self.lock
        key = DependencyKey(dependency_type, component)
        try:
            if not lock:
                return self._get_unlocked(key)
            with lock:
                return self._get_unlocked(key)
        except (NoFactoryError, NoActiveFactoryError) as e:
            e.scope = self.scope
            raise
    def _get(self, key: DependencyKey) -> Any:
        lock = self.lock
        if not lock:
            return self._get_unlocked(key)
        with lock:
            return self._get_unlocked(key)
    def _get_unlocked(self, key: DependencyKey) -> Any:
        if key in self._cache:
            return self._cache[key]
        compiled = self.registry.get_compiled(key)
        if not compiled:
            if not self.parent_container:
                abstract_dependencies = (
                    self.registry.get_more_abstract_factories(key)
                )
                concrete_dependencies = (
                    self.registry.get_more_concrete_factories(key)
                )

                raise NoFactoryError(
                    key,
                    suggest_abstract_factories=abstract_dependencies,
                    suggest_concrete_factories=concrete_dependencies,
                )
            try:
                return self.parent_container._get(key)  # noqa: SLF001
            except NoFactoryError as ex:
                abstract_dependencies = (
                    self.registry.get_more_abstract_factories(key)
                )
                concrete_dependencies = (
                    self.registry.get_more_concrete_factories(key)
                )
                ex.suggest_abstract_factories.extend(abstract_dependencies)
                ex.suggest_concrete_factories.extend(concrete_dependencies)
                raise
        try:
            return compiled(
                self._get_unlocked,
                self._exits,
                self._cache,
                self._context,
            )
        except NoFactoryError as e:
            # cast is needed because registry.get_factory will always
            # return Factory. This happens because registry.get_compiled
            # uses the same method and returns None if the factory is not found
            # If None is returned, then go to the parent container
            e.add_path(cast(Factory, self.registry.get_factory(key)))
            raise
        except NoActiveFactoryError as e:
            e.add_path(cast(Factory, self.registry.get_factory(key)))
            raise
    def close(self, exception: BaseException | None = None) -> None:
        errors = []
        for exit_generator in self._exits[::-1]:
            try:
                if exit_generator.type is FactoryType.GENERATOR:
                    exit_generator.callable.send(exception)  # type: ignore[attr-defined]
            except StopIteration:  # noqa: PERF203
                pass
            except Exception as err:  # noqa: BLE001
                errors.append(err)
        self._cache = {CONTAINER_KEY: self}
        if self.close_parent and self.parent_container:
            try:
                self.parent_container.close(exception)
            except Exception as err:  # noqa: BLE001
                errors.append(err)
        if errors:
            raise ExitError("Cleanup context errors", errors)  # noqa: TRY003
    def _has(self, marker: DependencyKey) -> bool:
        compiled = self.registry.get_compiled_activation(marker)
        if not compiled:
            if not self.parent_container:
                return False
            return self.parent_container._has(marker)  # noqa: SLF001
        return bool(compiled(
            self._get_unlocked,
            self._exits,
            self._cache,
            self._context,
        ))
    def _has_context(self, marker: Any) -> bool:
        return marker in self._context
class ContextWrapper:
    __slots__ = ("container",)
    def __init__(self, container: Container):
        self.container = container
    def __enter__(self) -> Container:
        return self.container
    def __exit__(
        self,
        exc_type: type[BaseException] | None = None,
        exc_val: BaseException | None = None,
        exc_tb: TracebackType | None = None,
    ) -> None:
        self.container.close(exception=exc_val)
class HasProvider(Provider):
    @activate(Has)
    def has(
        self,
        marker: DependencyKey,
        container: Container,
    ) -> bool:
        key = DependencyKey(marker.type_hint.value, marker.component)
        return container._has(key)  # noqa: SLF001
    @activate(HasContext)
    def has_context(
        self,
        marker: HasContext,
        container: Container,
    ) -> bool:
        return container._has_context(marker.value)   # noqa: SLF001
def make_container(
        *providers: BaseProvider,
        scopes: type[BaseScope] = Scope,
        context: dict[Any, Any] | None = None,
        lock_factory: Callable[[], AbstractContextManager[Any]] | None = Lock,
        skip_validation: bool = False,
        start_scope: BaseScope | None = None,
        validation_settings: ValidationSettings = DEFAULT_VALIDATION,
) -> Container:
    context_provider = make_root_context_provider(providers, context, scopes)
    has_provider = HasProvider()
    builder = GraphBuilder(
        scopes=scopes,
        container_key=CONTAINER_KEY,
        skip_validation=skip_validation,
        validation_settings=validation_settings,
    )
    builder.add_multicomponent_providers(has_provider)
    builder.add_providers(*providers)
    builder.add_providers(context_provider)
    registries = builder.build()
    container = Container(
        *registries,
        context=context,
        lock_factory=lock_factory,
    )
    if start_scope is None:
        while container.registry.scope.skip:
            container = Container(
                *container.child_registries,
                parent_container=container,
                context=context,
                lock_factory=lock_factory,
                close_parent=True,
            )
    else:
        while container.registry.scope is not start_scope:
            container = Container(
                *container.child_registries,
                parent_container=container,
                context=context,
                lock_factory=lock_factory,
                close_parent=True,
            )
    return container
CONTAINER_KEY = DependencyKey(Container, DEFAULT_COMPONENT)
container_objects.py
from abc import abstractmethod
from collections.abc import Callable
from dataclasses import dataclass
from typing import Any, Protocol
from dishka.entities.factory_type import FactoryType
@dataclass(slots=True)
class Exit:
    type: FactoryType
    callable: Callable[..., Any]
class CompiledFactory(Protocol):
    @abstractmethod
    def __call__(
            self,
            getter: Callable[..., Any],
            exits: list[Exit],
            cache: Any,
            context: Any,
    ) -> Any:
        raise NotImplementedError
context_proxy.py
from collections.abc import Iterator, MutableMapping
from typing import Any, NoReturn
from .entities.key import DependencyKey
class ContextProxy(MutableMapping[DependencyKey, Any]):
    def __init__(
            self,
            context: dict[DependencyKey, Any],
            cache: dict[DependencyKey, Any],
    ) -> None:
        self._cache = cache
        self._context = context
    def __setitem__(self, key: DependencyKey, value: Any) -> None:
        self._cache[key] = value
        self._context[key] = value
    def __delitem__(self, key: DependencyKey) -> NoReturn:
        raise RuntimeError(  # noqa: TRY003
            "Cannot delete anything from context",
        )
    def __getitem__(self, key: DependencyKey) -> Any:
        return self._cache[key]
    def __len__(self) -> int:
        return len(self._cache)
    def __iter__(self) -> Iterator[DependencyKey]:
        return iter(self._cache)
exception_base.py
from typing import Any
class DishkaError(Exception):
    pass
class InvalidMarkerError(DishkaError):
    def __init__(self, marker: Any) -> None:
        self.marker = marker
        self.source_name: str | None = None

    def __str__(self) -> str:
        msg = f"Cannot use {self.marker!r} as marker."
        if self.source_name:
            msg += f"\nUsed in: {self.source_name}"
        return msg
exceptions.py
from collections.abc import Sequence

from dishka.dependency_source.factory import Factory
from dishka.entities.factory_type import FactoryData
from dishka.entities.marker import Marker
from dishka.exception_base import DishkaError
from dishka.text_rendering import get_name
from dishka.text_rendering.path import PathRenderer
from dishka.text_rendering.suggestion import render_suggestions_for_missing
from .entities.key import DependencyKey
from .entities.scope import BaseScope
from .text_rendering.name import get_source_name
try:
    from builtins import (  # type: ignore[attr-defined, unused-ignore]
        ExceptionGroup,
    )
except ImportError:
    from exceptiongroup import (  # type: ignore[no-redef, import-not-found, unused-ignore]
        ExceptionGroup,
    )
_cycle_renderer = PathRenderer(cycle=True)
_linear_renderer = PathRenderer(cycle=False)
class ExitError(
    ExceptionGroup[Exception],  # type: ignore[misc, unused-ignore]
    DishkaError,
):
    pass
class NoContextValueError(DishkaError):
    pass
class UnsupportedFactoryError(DishkaError):
    def __init__(self, factory_type: FactoryData) -> None:
        self.factory_type = factory_type
    def __str__(self) -> str:
        return f"Unsupported factory type {self.factory_type}."
class InvalidGraphError(DishkaError):
    pass
class InvalidSubfactoryScopeError(InvalidGraphError):
    def __init__(self, factory: Factory, subfactory: Factory) -> None:
        self.factory = factory
        self.subfactory = subfactory
    def __str__(self) -> str:
        name = get_source_name(self.factory)
        sub_name = get_source_name(self.subfactory)
        return (
            f"`{name}` with scope {self.factory.scope} cannot use "
            f"`{sub_name}` with scope {self.subfactory.scope}"
        )
class NoActivatorError(InvalidGraphError):
    def __init__(
        self,
        marker_key: DependencyKey,
        requesting_factories: Sequence[Factory] = (),
    ) -> None:
        self.marker_key = marker_key
        self.requesting_factories = requesting_factories
    def _get_when_expression(self, factory: Factory) -> str:
        when = factory.when_active or factory.when_override
        return repr(when) if when else ""
    def __str__(self) -> str:
        msg = (
            f"Cannot find activator for {self.marker_key.type_hint}"
            f" at component {self.marker_key.component!r}."
        )
        if self.requesting_factories:
            msg += "\nUsed in:"
            for factory in self.requesting_factories:
                source = get_source_name(factory)
                when_expr = self._get_when_expression(factory)
                msg += f"\n  - {source}: {when_expr}"
        return msg
class ActivatorOverrideError(DishkaError):
    def __init__(
        self,
        marker: Marker | type[Marker],
        activators: Sequence[FactoryData],
    ) -> None:
        self.marker = marker
        self.activators = activators
    def __str__(self) -> str:
        return (
            f"Multiple activators found for {self.marker}: "
            f"{', '.join(map(get_source_name, self.activators))}"
        )
class WhenOverrideConflictError(DishkaError):
    def __str__(self) -> str:
        return "Cannot have both `when` and `override` set. "
class NoFactoryError(DishkaError):
    def __init__(
        self,
        requested: DependencyKey,
        path: Sequence[FactoryData] = (),
        suggest_other_scopes: Sequence[FactoryData] = (),
        suggest_other_components: Sequence[FactoryData] = (),
        suggest_abstract_factories: Sequence[FactoryData] = (),
        suggest_concrete_factories: Sequence[FactoryData] = (),
    ) -> None:
        self.requested = requested
        self.path = list(path)
        self.suggest_other_scopes = suggest_other_scopes
        self.suggest_other_components = suggest_other_components
        self.suggest_abstract_factories = list(
            suggest_abstract_factories,
        )
        self.suggest_concrete_factories = list(
            suggest_concrete_factories,
        )
        self.scope: BaseScope | None = None
    def add_path(self, requested_by: FactoryData) -> None:
        self.path.insert(0, requested_by)
    def __str__(self) -> str:
        suggestion = render_suggestions_for_missing(
            requested_for=self.path[-1] if self.path else None,
            requested_key=self.requested,
            suggest_other_scopes=self.suggest_other_scopes,
            suggest_other_components=self.suggest_other_components,
            suggest_abstract_factories=self.suggest_abstract_factories,
            suggest_concrete_factories=self.suggest_concrete_factories,
        )
        if suggestion:
            suggestion = f" Hint:{suggestion}"
        requested_name = get_name(
            self.requested.type_hint, include_module=False,
        )
        if self.path:
            requested_repr = (
                f"({requested_name}, "
                f"component={self.requested.component!r})"
            )
            return (
                f"Cannot find factory for {requested_repr}. "
                f"It is missing or has invalid scope.\n"
            ) + _linear_renderer.render(self.path, self.requested) + suggestion
        else:
            requested_repr = (
                f"({requested_name}, "
                f"component={self.requested.component!r}, "
                f"scope={self.scope!s})"
            )
            return (
                f"Cannot find factory for {requested_repr}. "
                f"Check scopes in your providers. "
                f"It is missing or has invalid scope."
            ) + suggestion
class NoActiveFactoryError(DishkaError):
    def __init__(
        self,
        requested: DependencyKey,
        variants: Sequence[FactoryData],
        path: Sequence[FactoryData] = (),
    ) -> None:
        self.requested = requested
        self.variants = variants
        self.path = list(path)
        self.scope: BaseScope | None = None
    def add_path(self, requested_by: FactoryData) -> None:
        self.path.insert(0, requested_by)
    def __str__(self) -> str:
        requested_name = get_name(
            self.requested.type_hint, include_module=False,
        )
        requested_repr = (
            f"({requested_name}, "
            f"component={self.requested.component!r})"
        )
        return (
            f"Cannot select active factory for {requested_repr}. "
            f"All variants are not active.\n"
        ) + _linear_renderer.render(self.path, None, self.variants)
class AliasedFactoryNotFoundError(ValueError, DishkaError):
    def __init__(
            self, dependency: DependencyKey, alias: FactoryData,
    ) -> None:
        self.dependency = dependency
        self.alias_provider = alias.provides
    def __str__(self) -> str:
        return (
            f"Factory for {self.dependency} "
            f"aliased from {self.alias_provider} is not found"
        )
class NoChildScopesError(ValueError, DishkaError):
    def __str__(self) -> str:
        return "No child scopes found"
class NoNonSkippedScopesError(ValueError, DishkaError):
    def __str__(self) -> str:
        return "No non-skipped scopes found."
class ChildScopeNotFoundError(ValueError, DishkaError):
    def __init__(
            self,
            assumed_child_scope: BaseScope | None,
            current_scope: BaseScope | None,
    ) -> None:
        self.child_scope = assumed_child_scope
        self.current_scope = current_scope
    def __str__(self) -> str:
        return (
            f"Cannot find {self.child_scope} as a "
            f"child of current {self.current_scope}"
        )
class UnknownScopeError(InvalidGraphError):
    def __init__(
            self,
            scope: BaseScope | None,
            expected: type[BaseScope],
            factory: FactoryData,
            extend_message: str = "",
    ) -> None:
        self.scope = scope
        self.expected = expected
        self.factory = factory
        self.extend_message = extend_message
    def __str__(self) -> str:
        name = get_name(self.factory.source, include_module=False)
        return " ".join((
            f"Scope {self.scope} at `{name}` is unknown, "
            f"expected one of {self.expected}.",
            self.extend_message,
        ))
class CycleDependenciesError(InvalidGraphError):
    def __init__(self, path: Sequence[FactoryData]) -> None:
        self.path = path
    def __str__(self) -> str:
        if len(self.path) == 1:
            hint = " Did you mean @decorate instead of @provide?"
        else:
            hint = ""
        details = _cycle_renderer.render(self.path)
        return f"Cycle dependencies detected.{hint}\n{details}"
class GraphMissingFactoryError(NoFactoryError, InvalidGraphError):
    pass
class ImplicitOverrideDetectedError(InvalidGraphError):
    def __init__(self, new: FactoryData, existing: FactoryData) -> None:
        self.new = new
        self.existing = existing
    def __str__(self) -> str:
        new_name = get_name(self.new.source, include_module=False)
        existing_name = get_name(self.existing.source, include_module=False)
        return (
            f"Detected multiple factories for {self.new.provides} "
            f"while `override` flag is not set.\n"
            "Hint:\n"
            f" * Try specifying `override=True` for {new_name}\n"
            f" * Try removing factory {existing_name} or {new_name}\n"
        )
class NothingOverriddenError(InvalidGraphError):
    def __init__(self, factory: FactoryData) -> None:
        self.factory = factory
    def __str__(self) -> str:
        name = get_name(self.factory.source, include_module=False)
        return (
            f"Overriding factory found for {self.factory.provides}, "
            "but there is nothing to override.\n"
            "Hint:\n"
            f" * Try removing override=True from {name}\n"
            f" * Check the order of providers\n"
        )
registry.py
from abc import ABC, ABCMeta
from enum import Enum
from typing import (
    Any,
    Final,
    Generic,
    Protocol,
    TypeAlias,
    TypeVar,
    get_args,
    get_origin,
)

from ._adaptix.type_tools.basic_utils import is_generic
from ._adaptix.type_tools.fundamentals import get_type_vars
from .code_tools.factory_compiler import compile_activation, compile_factory
from .container_objects import CompiledFactory
from .dependency_source import (
    Factory,
)
from .dependency_source.type_match import (
    get_typevar_replacement,
    is_broader_or_same_type,
)
from .entities.factory_type import FactoryType
from .entities.key import DependencyKey
from .entities.marker import Marker
from .entities.scope import BaseScope
IGNORE_TYPES: Final = (
    type,
    object,
    Enum,
    ABC,
    ABCMeta,
    Generic,
    Protocol,
    Exception,
    BaseException,
)
CompiledFactories: TypeAlias = dict[DependencyKey, CompiledFactory]
class Registry:
    __slots__ = (
        "compiled",
        "compiled_activation",
        "compiled_activation_async",
        "compiled_async",
        "factories",
        "has_fallback",
        "scope",
    )
    def __init__(self, scope: BaseScope, *, has_fallback: bool) -> None:
        self.scope = scope
        self.factories: dict[DependencyKey, Factory] = {}
        self.compiled: CompiledFactories = {}
        self.compiled_async: CompiledFactories = {}
        self.compiled_activation: CompiledFactories = {}
        self.compiled_activation_async: CompiledFactories = {}
        self.has_fallback = has_fallback
    def add_factory(
            self,
            factory: Factory,
            provides: DependencyKey | None = None,
    ) -> None:
        if provides is None:
            provides = factory.provides
        self.factories[provides] = factory
        if is_generic(factory.provides.type_hint):
            origin = get_origin(factory.provides.type_hint)
            origin_key = DependencyKey(
                origin,
                factory.provides.component,
                factory.provides.depth,
            )
            self.factories[origin_key] = factory
    def get_compiled(
            self, dependency: DependencyKey,
    ) -> CompiledFactory | None:
        try:
            return self.compiled[dependency]
        except KeyError:
            factory = self.get_factory(dependency)
            if not factory:
                return None
            compiled = compile_factory(factory=factory, is_async=False)
            self.compiled[dependency] = compiled
            return compiled
    def get_compiled_async(
            self, dependency: DependencyKey,
    ) -> CompiledFactory | None:
        try:
            return self.compiled_async[dependency]
        except KeyError:
            factory = self.get_factory(dependency)
            if not factory:
                return None
            compiled = compile_factory(factory=factory, is_async=True)
            self.compiled_async[dependency] = compiled
            return compiled
    def get_compiled_activation(
            self, dependency: DependencyKey,
    ) -> CompiledFactory | None:
        try:
            return self.compiled_activation[dependency]
        except KeyError:
            factory = self.get_factory(dependency)
            if not factory:
                return None
            compiled = compile_activation(factory=factory, is_async=False)
            self.compiled_activation[dependency] = compiled
            return compiled
    def get_compiled_activation_async(
            self, dependency: DependencyKey,
    ) -> CompiledFactory | None:
        try:
            return self.compiled_activation_async[dependency]
        except KeyError:
            factory = self.get_factory(dependency)
            if not factory:
                return None
            compiled = compile_activation(factory=factory, is_async=True)
            self.compiled_activation_async[dependency] = compiled
            return compiled
    def get_factory(self, dependency: DependencyKey) -> Factory | None:
        try:
            return self.factories[dependency]
        except KeyError:
            if isinstance(dependency.type_hint, Marker):
                return None
            origin = get_origin(dependency.type_hint)
            if not origin:
                return None
            if (origin is type) and self.has_fallback:
                return self._get_type_var_factory(dependency)
            origin_key = DependencyKey(
                origin,
                dependency.component,
                dependency.depth,
            )
            factory = self.factories.get(origin_key)

            if (
                not factory or
                not is_broader_or_same_type(
                    factory.provides.type_hint,
                    dependency.type_hint,
                )
            ):
                return None
            factory = self._specialize_generic(factory, dependency)
            self.factories[dependency] = factory
            return factory
    def get_more_abstract_factories(
        self,
        dependency: DependencyKey,
    ) -> list[Factory]:
        abstract_dependencies: list[Factory] = []
        try:
            abstract_classes = dependency.type_hint.__bases__
        except AttributeError:
            abstract_classes = ()
        for abstract_class in abstract_classes:
            abstract_dependency = DependencyKey(
                abstract_class,
                dependency.component,
            )
            factory = self.factories.get(abstract_dependency)
            if factory is not None:
                abstract_dependencies.append(factory)
        return abstract_dependencies
    def get_more_concrete_factories(
        self,
        dependency: DependencyKey,
    ) -> list[Factory]:
        concrete_factories: list[Factory] = []
        check_type_hint = dependency.type_hint
        if check_type_hint in IGNORE_TYPES:
            return concrete_factories
        try:
            subclasses: list[Any] = check_type_hint.__subclasses__()
        except AttributeError:
            subclasses = []
        for subclass in subclasses:
            concrete_dependency = DependencyKey(
                subclass,
                dependency.component,
            )
            factory = self.factories.get(concrete_dependency)
            if factory is not None:
                concrete_factories.append(factory)
        return concrete_factories
    def _get_type_var_factory(self, dependency: DependencyKey) -> Factory:
        args = get_args(dependency.type_hint)
        if args:
            typevar = args[0]
        else:
            typevar = Any
        return Factory(
            scope=self.scope,
            dependencies=[],
            kw_dependencies={},
            provides=DependencyKey(type[typevar], dependency.component),
            type_=FactoryType.FACTORY,
            is_to_bind=False,
            cache=False,
            source=lambda: typevar,
            when_override=None,
            when_active=None,
            when_component=None,
            when_dependencies=[],
        )
    def _specialize_generic(
            self, factory: Factory, dependency_key: DependencyKey,
    ) -> Factory:
        params_replacement = get_typevar_replacement(
            factory.provides.type_hint,
            dependency_key.type_hint,
        )
        new_dependencies: list[DependencyKey] = []
        for source_dependency in factory.dependencies:
            hint = source_dependency.type_hint
            if isinstance(hint, TypeVar):
                hint = params_replacement[hint]
            elif get_origin(hint) and (type_vars := get_type_vars(hint)):
                hint = hint[tuple(
                    params_replacement[param]
                    for param in type_vars
                )]
            new_dependencies.append(DependencyKey(
                hint, source_dependency.component, source_dependency.depth,
            ))
        new_kw_dependencies: dict[str, DependencyKey] = {}
        for name, source_dependency in factory.kw_dependencies.items():
            hint = source_dependency.type_hint
            if isinstance(hint, TypeVar):
                hint = params_replacement[hint]
            elif get_origin(hint) and (type_vars := get_type_vars(hint)):
                hint = hint[tuple(
                    params_replacement[param]
                    for param in type_vars
                )]
            new_kw_dependencies[name] = DependencyKey(
                hint, source_dependency.component, source_dependency.depth,
            )
        return Factory(
            source=factory.source,
            provides=dependency_key,
            dependencies=new_dependencies,
            kw_dependencies=new_kw_dependencies,
            is_to_bind=factory.is_to_bind,
            type_=factory.type,
            scope=factory.scope,
            cache=factory.cache,
            when_override=factory.when_override,
            when_active=factory.when_active,
            when_component=factory.when_component,
            when_dependencies=factory.when_dependencies,
        )
